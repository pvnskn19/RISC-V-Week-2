# RISC-V-Week-2
Learnings and Lab results from RISC-V Chip Tapeout Workshop in Week 2

# **System-on-Chip (SoC)**

## **What is a System-on-Chip (SoC)?**

A **System-on-Chip (SoC)** is an integrated circuit (IC) that combines **all major components of a computer or electronic system** into a single chip.  
Unlike traditional systems where the CPU, memory, and peripherals are on separate chips connected via a motherboard, an SoC integrates everything on one silicon die.

> **Definition:**  
> A System-on-Chip (SoC) integrates a processor, memory, input/output ports, communication interfaces, and other peripherals into a single chip to perform a complete set of functions.

**Used in:** Smartphones, embedded devices, IoT systems, automotive controllers, etc.

---

## **Components of a Typical SoC**

A typical SoC consists of the following main components:

### 1. **CPU (Processor Core)**
- The **brain** of the SoC — executes program instructions.  
- Based on architectures like **ARM**, **RISC-V**, or **x86**.  
- Can be single-core or multi-core for performance and efficiency.

### 2. **Memory**
- **On-chip memory** (e.g., SRAM, ROM) for fast data access.  
- **External memory interfaces** (e.g., DDR controller) for large storage.  
- Stores both **program code** and **data**.

### 3. **Peripherals (I/O Interfaces and Controllers)**
- Manage communication and control with external devices:  
  - UART, SPI, I2C (communication)  
  - GPIO (general-purpose I/O)  
  - Timers, ADC/DAC, interrupt controllers, etc.  
- Typically accessed via **memory-mapped registers**.

### 4. **Interconnect / Bus System**
- Provides **data communication** between CPU, memory, and peripherals.  
- Common types: **AMBA (AXI, AHB, APB)**, **Wishbone**, etc.  
- Functions like an internal data highway connecting all modules.

## **Why BabySoC is a Simplified Model for Learning SoC Concepts**

**BabySoC** is a minimal educational SoC design — created to help students learn **how SoCs are structured and built** without industrial complexity.

### **Simplifications**
- Single lightweight CPU (like **PicoRV32** or a basic **RISC-V** core).  
- Few peripherals (UART, GPIO).  
- Simple memory subsystem (small SRAM, no cache).  
- Basic interconnect (e.g., **Wishbone** or **AXI-Lite**).

### **Learning Benefits**
- Easy to understand **data flow and communication** inside an SoC.  
- Enables practice with **RTL design**, **simulation**, and **synthesis**.  
- Compatible with **open-source EDA tools** (Yosys, OpenLane).  
- Acts as a **bridge** between theory and practical chip design.

---

## **Role of Functional Modelling Before RTL and Physical Design**

Functional modelling is an **early SoC design stage** where system behavior is verified **before** writing RTL code.

### **Purpose**
- Validate the **architecture and logic flow**.  
- Ensure correct **CPU–memory–peripheral** interactions.  
- Detect and fix **conceptual design errors early**.

### **How it Works**
- Written in **high-level languages** (C, Python, or SystemC).  
- Focuses on **functionality**, not timing or circuit details.  
- Example: simulate CPU–memory data transfer before Verilog coding.

### **Benefits**
- Early detection of design flaws.  
- Reduces time and cost before synthesis/layout.  
- Provides a **reference model** for later RTL verification.

# Lab Component
## Directory (in VSDBabySoC)
```
├── images
├── output
│   ├── compiled_tlv
│   ├── post_synth_sim
│   ├── pre_synth_sim
│   ├── synth
│   └── vsdbabysoc_layout
└── src
    ├── gds
    ├── gls_model
    ├── include
    ├── layout_conf
    │   ├── rvmyth
    │   └── vsdbabysoc
    ├── lef
    ├── lib
    ├── module
    ├── script
    └── sdc
```
### Pre requisites:
Install sandpiper-saas (for making a .v file from .tlv file):
```
sudo apt install pipx
pipx ensurepath
pipx install sandpiper-saas
```
Github Cloning: </br>
```$ git clone https://github.com/manili/VSDBabySoC.git```
## Pre-synthesis
.vcd file was generated by:
```
$ cd VSDBabySoC
$ make pre_synth_sim
```
![](/images/pre_synth_waveform.png)<sjd>
The  .vcd file was dumped in gtkwave for visualizing the waveform (above is the resulting waveform) :</br>
```$ gtkwave output/pre_synth_sim/pre_synth_sim.vcd```
## Synthesis
Next the design file is converted in gate level design (or netlist) by using yosys:
```
$ cd ~/VSDBabySoC
$ make synth
```
Following report was generated: 
```
=== vsdbabysoc ===

   Number of wires:               5220
   Number of wire bits:           6694
   Number of public wires:        5220
   Number of public wire bits:    6694
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               6396
     avsddac                         1
     avsdpll                         1
     sky130_fd_sc_hd__a2111oi_0      1
     sky130_fd_sc_hd__a211o_2       32
     sky130_fd_sc_hd__a211oi_1       4
     sky130_fd_sc_hd__a21boi_0       4
     sky130_fd_sc_hd__a21oi_1      989
     sky130_fd_sc_hd__a221oi_1      62
     sky130_fd_sc_hd__a22oi_1      358
     sky130_fd_sc_hd__a31o_2         2
     sky130_fd_sc_hd__a31oi_1       26
     sky130_fd_sc_hd__a32o_1         1
     sky130_fd_sc_hd__a32oi_1        4
     sky130_fd_sc_hd__a41oi_1        1
     sky130_fd_sc_hd__and2_2        11
     sky130_fd_sc_hd__and3_2         1
     sky130_fd_sc_hd__clkinv_1     371
     sky130_fd_sc_hd__dfxtp_1     1144
     sky130_fd_sc_hd__lpflow_inputiso0p_1      1
     sky130_fd_sc_hd__mux2i_1        6
     sky130_fd_sc_hd__nand2_1     2037
     sky130_fd_sc_hd__nand3_1       72
     sky130_fd_sc_hd__nand3b_1       2
     sky130_fd_sc_hd__nand4_1      107
     sky130_fd_sc_hd__nor2_1       400
     sky130_fd_sc_hd__nor3_1        28
     sky130_fd_sc_hd__nor4_1         5
     sky130_fd_sc_hd__o2111ai_1      5
     sky130_fd_sc_hd__o211ai_1      18
     sky130_fd_sc_hd__o21a_1        29
     sky130_fd_sc_hd__o21ai_0      514
     sky130_fd_sc_hd__o21ba_2        1
     sky130_fd_sc_hd__o21bai_1      29
     sky130_fd_sc_hd__o221a_2        1
     sky130_fd_sc_hd__o221ai_1       3
     sky130_fd_sc_hd__o22ai_1       28
     sky130_fd_sc_hd__o311ai_0       2
     sky130_fd_sc_hd__o31ai_1        3
     sky130_fd_sc_hd__o32ai_1        1
     sky130_fd_sc_hd__o41ai_1        2
     sky130_fd_sc_hd__or2_2         23
     sky130_fd_sc_hd__xnor2_1       19
     sky130_fd_sc_hd__xor2_1        47
```
## Post-synthesis
The generated netlist is tested against the same testbench to check for any errors in the circuit design which occured during gate level implementation:
```
$ cd ~/VSDBabySoC
$ make post_synth_sim
```
![](/images/post_synth_waveform.png)<sjd>
The  .vcd file was dumped in gtkwave for visualizing the waveform (above is the resulting waveform) : </br>
```$ gtkwave output/post_synth_sim/post_synth_sim.vcd```
# Debugging 
## No rvmyth.v file
This was resolved by using sandpiper saas installed in the starting 
## Synthesising without OpenLane:
The makefile is instructed to use OpenLane for synthesising the VSDBabySoC. Appropriate changes were made such that pre-installed yosys was used. Also I am using pipx commands, so changes regarding the same were done.
```
if [ ! -f "output/synth/vsdbabysoc.synth.v" ]; then \
		mkdir -p output/synth; \
		cd src && yosys -s script/yosys.ys | tee ../output/synth/synth.log; \
	fi
```
<p align="center">Changes in Makefile</p>

# Conclusion
![](/images/pre_synth_waveform.png)
            <p align="center">Pre synthesis waveform</p>
![](/images/post_synth_waveform.png)
         <p align="center">Post synthesis waveform</p>
      </br>
From comparing both the waveforms, we can see no disimilarities implying that synthesis was successful in genearating a proper gate level design. 

